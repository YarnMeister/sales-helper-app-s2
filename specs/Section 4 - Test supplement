## Test Data Management Supplement
### For Neon Database + Upstash Redis Setup

### Overview
This supplement addresses proper test data seeding and cleanup for apps using Neon PostgreSQL with Upstash Redis, preventing the data pollution issues that cause AI assistants to write defensive null-checking code.

---

### 1. Environment-Based Data Isolation

**Goal:** Ensure test data never pollutes development or production data

**Cursor Prompt:**
```
Set up proper environment-based data isolation for Neon database with Upstash Redis.

Create `/lib/config/test-env.ts`:

import { createClient } from '@supabase/supabase-js';
import { Redis } from '@upstash/redis';

// Environment detection
export const getAppEnv = () => {
  if (process.env.NODE_ENV === 'test' || process.env.APP_ENV === 'test') {
    return 'test';
  }
  if (process.env.VERCEL_ENV === 'preview') {
    return 'preview';
  }
  return process.env.NODE_ENV || 'development';
};

// Database configuration with proper test isolation
export const getDatabaseConfig = () => {
  const env = getAppEnv();
  
  // Use different table prefixes for test environment
  const tablePrefix = env === 'test' ? 'test_' : '';
  
  return {
    env,
    tablePrefix,
    // Use same Neon instance but with prefixed tables for tests
    supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL!,
    supabaseKey: process.env.SUPABASE_SERVICE_ROLE_KEY!,
    tables: {
      requests: `${tablePrefix}requests`,
      kvCache: `${tablePrefix}kv_cache`,
      mockSubmissions: `${tablePrefix}mock_pipedrive_submissions`
    }
  };
};

// Redis configuration with test namespace
export const getRedisConfig = () => {
  const env = getAppEnv();
  const keyPrefix = env === 'test' ? 'test:' : '';
  
  return {
    redis: new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL!,
      token: process.env.UPSTASH_REDIS_REST_TOKEN!,
    }),
    keyPrefix,
    // Helper to get namespaced keys
    getKey: (key: string) => `${keyPrefix}${key}`
  };
};

Update `/lib/db.ts`:

import { createClient } from '@supabase/supabase-js';
import { getDatabaseConfig } from './config/test-env';

let db: any = null;

export const getDb = () => {
  if (db) return db;
  
  const config = getDatabaseConfig();
  
  db = createClient(config.supabaseUrl, config.supabaseKey, {
    auth: { persistSession: false },
    db: { schema: 'public' }
  });
  
  return db;
};

// Helper to get correct table name based on environment
export const getTableName = (table: keyof ReturnType<typeof getDatabaseConfig>['tables']) => {
  const config = getDatabaseConfig();
  return config.tables[table];
};

// Updated generateRequestId with proper table naming
export const generateRequestId = async (): Promise<string> => {
  const db = getDb();
  const tableName = getTableName('requests');
  
  const { data, error } = await db
    .from(tableName)
    .select('request_id')
    .order('request_id', { ascending: false })
    .limit(1);

  if (error) throw error;

  if (!data || data.length === 0) {
    return 'QR-001';
  }

  const lastId = data[0].request_id;
  const match = lastId.match(/QR-(\d{3})/);
  
  if (!match) {
    return 'QR-001';
  }

  const nextNumber = parseInt(match[1]) + 1;
  return `QR-${nextNumber.toString().padStart(3, '0')}`;
};

Update `/lib/cache.ts`:

import { getRedisConfig } from './config/test-env';

export class KVCache {
  private redis;
  private keyPrefix;
  private getKey;

  constructor() {
    const config = getRedisConfig();
    this.redis = config.redis;
    this.keyPrefix = config.keyPrefix;
    this.getKey = config.getKey;
  }

  async set(key: string, data: any, ttlSeconds: number = 3600): Promise<void> {
    const namespacedKey = this.getKey(key);
    
    const cacheItem = {
      data,
      timestamp: Date.now(),
      ttl: ttlSeconds * 1000
    };

    await this.redis.setex(namespacedKey, ttlSeconds, JSON.stringify(cacheItem));
  }

  async get(key: string): Promise<{ data: any; stale: boolean } | null> {
    const namespacedKey = this.getKey(key);
    const cached = await this.redis.get(namespacedKey);
    
    if (!cached) return null;

    try {
      const cacheItem = JSON.parse(cached as string);
      const age = Date.now() - cacheItem.timestamp;
      const stale = age > cacheItem.ttl;

      return { data: cacheItem.data, stale };
    } catch {
      return null;
    }
  }

  async bust(key: string): Promise<void> {
    const namespacedKey = this.getKey(key);
    await this.redis.del(namespacedKey);
  }

  async bustPattern(pattern: string): Promise<void> {
    const namespacedPattern = this.getKey(pattern);
    const keys = await this.redis.keys(namespacedPattern);
    
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

---

### 2. Test Database Schema Setup

**Goal:** Create test tables that mirror production but are completely isolated

**Cursor Prompt:**
```
Create test table setup script that mirrors production schema with test_ prefix.

Create `/tests/_setup/create-test-tables.sql`:

-- Test tables with same structure as production but prefixed
CREATE TABLE IF NOT EXISTS test_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    request_id TEXT UNIQUE NOT NULL,
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'submitted', 'in_progress', 'won', 'lost')),
    salesperson_first_name TEXT,
    mine_group TEXT,
    mine_name TEXT,
    contact JSONB,
    line_items JSONB DEFAULT '[]'::jsonb,
    comment TEXT,
    pipedrive_deal_id INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS test_kv_cache (
    key TEXT PRIMARY KEY,
    data JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE
);

CREATE TABLE IF NOT EXISTS test_mock_pipedrive_submissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    request_id TEXT NOT NULL,
    simulated_deal_id INTEGER NOT NULL,
    submission_data JSONB NOT NULL,
    status TEXT DEFAULT 'Submitted',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for test tables
CREATE INDEX IF NOT EXISTS idx_test_requests_status ON test_requests(status);
CREATE INDEX IF NOT EXISTS idx_test_requests_salesperson ON test_requests(salesperson_first_name);
CREATE INDEX IF NOT EXISTS idx_test_requests_created_at ON test_requests(created_at);
CREATE INDEX IF NOT EXISTS idx_test_kv_cache_expires_at ON test_kv_cache(expires_at);
CREATE INDEX IF NOT EXISTS idx_test_mock_submissions_request_id ON test_mock_pipedrive_submissions(request_id);

-- Function to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION update_test_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers for auto-updating timestamps
DROP TRIGGER IF EXISTS update_test_requests_updated_at ON test_requests;
CREATE TRIGGER update_test_requests_updated_at 
    BEFORE UPDATE ON test_requests 
    FOR EACH ROW EXECUTE FUNCTION update_test_updated_at_column();

DROP TRIGGER IF EXISTS update_test_kv_cache_updated_at ON test_kv_cache;
CREATE TRIGGER update_test_kv_cache_updated_at 
    BEFORE UPDATE ON test_kv_cache 
    FOR EACH ROW EXECUTE FUNCTION update_test_updated_at_column();

Create `/tests/_setup/setup-test-db.ts`:

import { getDb, getTableName } from '../../lib/db';
import { readFileSync } from 'fs';
import { join } from 'path';

export const setupTestDatabase = async () => {
  const db = getDb();
  
  try {
    // Read and execute the SQL setup script
    const sqlScript = readFileSync(
      join(__dirname, 'create-test-tables.sql'), 
      'utf8'
    );
    
    // Execute the SQL (Supabase client handles multiple statements)
    const { error } = await db.rpc('exec_sql', { sql: sqlScript });
    
    if (error) {
      console.error('Failed to setup test database:', error);
      throw error;
    }
    
    console.log('Test database tables created successfully');
    
  } catch (error) {
    console.error('Test database setup failed:', error);
    throw error;
  }
};

// Alternative approach if rpc doesn't work - execute statements individually
export const setupTestDatabaseManual = async () => {
  const db = getDb();
  
  // Create test_requests table
  const { error: requestsError } = await db.rpc('exec', {
    sql: `
      CREATE TABLE IF NOT EXISTS test_requests (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        request_id TEXT UNIQUE NOT NULL,
        status TEXT NOT NULL DEFAULT 'draft',
        salesperson_first_name TEXT,
        mine_group TEXT,
        mine_name TEXT,
        contact JSONB,
        line_items JSONB DEFAULT '[]'::jsonb,
        comment TEXT,
        pipedrive_deal_id INTEGER,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      );
    `
  });
  
  if (requestsError) throw requestsError;
  
  // Create other tables...
  // (Continue with other table creation statements)
};

export const teardownTestDatabase = async () => {
  const db = getDb();
  
  try {
    // Drop test tables
    await db.rpc('exec', {
      sql: `
        DROP TABLE IF EXISTS test_mock_pipedrive_submissions;
        DROP TABLE IF EXISTS test_kv_cache;
        DROP TABLE IF EXISTS test_requests;
        DROP FUNCTION IF EXISTS update_test_updated_at_column() CASCADE;
      `
    });
    
    console.log('Test database tables dropped successfully');
    
  } catch (error) {
    console.error('Test database teardown failed:', error);
    // Don't throw - teardown should be best effort
  }
};
```

---

### 3. Deterministic Test Data Factories

**Goal:** Create predictable, valid test data that never uses null values

**Cursor Prompt:**
```
Create robust test data factories that generate deterministic, valid data without nulls.

Create `/tests/_factories/base-factory.ts`:

// Base factory with guaranteed non-null data
export abstract class BaseFactory<T> {
  protected sequence = 1;
  
  protected nextId(): number {
    return this.sequence++;
  }
  
  protected nextString(prefix: string): string {
    return `${prefix}-${this.nextId().toString().padStart(3, '0')}`;
  }
  
  protected randomFromArray<U>(array: U[]): U {
    return array[Math.floor(Math.random() * array.length)];
  }
  
  abstract build(overrides?: Partial<T>): T;
  
  buildMany(count: number, overrides?: Partial<T>): T[] {
    return Array.from({ length: count }, () => this.build(overrides));
  }
}

Create `/tests/_factories/contact-factory.ts`:

import { BaseFactory } from './base-factory';
import { TContactJSON } from '../../lib/schema';

export class ContactFactory extends BaseFactory<TContactJSON> {
  private static readonly MINE_GROUPS = [
    'Anglo American',
    'Harmony Gold',
    'Gold Fields',
    'Sibanye-Stillwater'
  ];
  
  private static readonly MINE_NAMES = {
    'Anglo American': ['Zibulo Mine', 'Kopanang Mine', 'Moab Khotsong'],
    'Harmony Gold': ['Kusasalethu Mine', 'Bambanani Mine'],
    'Gold Fields': ['South Deep Mine', 'Beatrix Mine'],
    'Sibanye-Stillwater': ['Driefontein Mine', 'Kloof Mine']
  };
  
  private static readonly FIRST_NAMES = [
    'John', 'Jane', 'Michael', 'Sarah', 'David', 'Lisa', 
    'James', 'Emma', 'Robert', 'Anna'
  ];
  
  private static readonly LAST_NAMES = [
    'Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 
    'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez'
  ];

  build(overrides: Partial<TContactJSON> = {}): TContactJSON {
    const mineGroup = overrides.mineGroup || 
      this.randomFromArray(ContactFactory.MINE_GROUPS);
    
    const availableMines = ContactFactory.MINE_NAMES[mineGroup] || 
      ContactFactory.MINE_NAMES[ContactFactory.MINE_GROUPS[0]];
    
    const mineName = overrides.mineName || 
      this.randomFromArray(availableMines);
    
    const firstName = this.randomFromArray(ContactFactory.FIRST_NAMES);
    const lastName = this.randomFromArray(ContactFactory.LAST_NAMES);
    const fullName = `${firstName} ${lastName}`;
    
    const personId = overrides.personId || this.nextId() + 10000;
    const orgId = overrides.orgId || this.nextId() + 50000;
    
    return {
      personId,
      name: overrides.name || fullName,
      email: overrides.email || 
        `${firstName.toLowerCase()}.${lastName.toLowerCase()}@${mineName.toLowerCase().replace(/\s+/g, '')}.co.za`,
      phone: overrides.phone || 
        `+2711${(Math.floor(Math.random() * 9000000) + 1000000).toString()}`,
      orgId,
      orgName: overrides.orgName || mineName,
      mineGroup,
      mineName,
      ...overrides
    };
  }
  
  // Specific factory methods for common test scenarios
  buildForMineGroup(mineGroup: string): TContactJSON {
    return this.build({ mineGroup });
  }
  
  buildForMine(mineGroup: string, mineName: string): TContactJSON {
    return this.build({ mineGroup, mineName });
  }
}

Create `/tests/_factories/line-item-factory.ts`:

import { BaseFactory } from './base-factory';
import { TLineItem } from '../../lib/schema';

export class LineItemFactory extends BaseFactory<TLineItem> {
  private static readonly CATEGORIES = [
    'Safety Equipment',
    'Communication Devices',
    'Monitoring Systems',
    'Power Equipment',
    'Ventilation Systems'
  ];
  
  private static readonly PRODUCTS = {
    'Safety Equipment': [
      { name: 'AirRobo Sensor', code: 'AR-001', price: 150.00 },
      { name: 'Safety Helmet', code: 'SH-001', price: 75.00 },
      { name: 'Emergency Beacon', code: 'EB-001', price: 200.00 }
    ],
    'Communication Devices': [
      { name: 'Radio Device', code: 'RD-001', price: 180.00 },
      { name: 'Intercom System', code: 'IS-001', price: 350.00 }
    ],
    'Monitoring Systems': [
      { name: 'Gas Monitor', code: 'GM-001', price: 250.00 },
      { name: 'Temperature Sensor', code: 'TS-001', price: 120.00 }
    ],
    'Power Equipment': [
      { name: 'Battery Pack', code: 'BP-001', price: 90.00 },
      { name: 'Power Converter', code: 'PC-001', price: 160.00 }
    ],
    'Ventilation Systems': [
      { name: 'Air Filter', code: 'AF-001', price: 80.00 },
      { name: 'Ventilation Fan', code: 'VF-001', price: 220.00 }
    ]
  };

  build(overrides: Partial<TLineItem> = {}): TLineItem {
    const category = overrides.category || 
      this.randomFromArray(LineItemFactory.CATEGORIES);
    
    const products = LineItemFactory.PRODUCTS[category] || 
      LineItemFactory.PRODUCTS[LineItemFactory.CATEGORIES[0]];
    
    const product = this.randomFromArray(products);
    
    return {
      pipedriveProductId: overrides.pipedriveProductId || this.nextId() + 90000,
      name: overrides.name || product.name,
      code: overrides.code || product.code,
      category: category,
      price: overrides.price !== undefined ? overrides.price : product.price,
      quantity: overrides.quantity || Math.floor(Math.random() * 5) + 1,
      shortDescription: overrides.shortDescription || 
        `${product.name} for mining operations`,
      ...overrides
    };
  }
  
  buildForCategory(category: string): TLineItem {
    return this.build({ category });
  }
  
  buildWithQuantity(quantity: number): TLineItem {
    return this.build({ quantity });
  }
}

Create `/tests/_factories/request-factory.ts`:

import { BaseFactory } from './base-factory';
import { TRequestUpsert } from '../../lib/schema';
import { ContactFactory } from './contact-factory';
import { LineItemFactory } from './line-item-factory';

export class RequestFactory extends BaseFactory<TRequestUpsert> {
  private contactFactory = new ContactFactory();
  private lineItemFactory = new LineItemFactory();
  
  private static readonly SALESPEOPLE = [
    'Luyanda', 'James', 'Stefan'
  ];
  
  private static readonly COMMENTS = [
    'Standard equipment request for safety compliance',
    'Urgent replacement needed for damaged equipment',
    'Quarterly maintenance equipment order',
    'New employee safety equipment setup',
    'Equipment upgrade for improved efficiency'
  ];

  build(overrides: Partial<TRequestUpsert> = {}): TRequestUpsert {
    const mineGroup = overrides.mineGroup || 'Anglo American';
    const mineName = overrides.mineName || 'Zibulo Mine';
    
    return {
      salespersonFirstName: overrides.salespersonFirstName || 
        this.randomFromArray(RequestFactory.SALESPEOPLE),
      mineGroup,
      mineName,
      contact: overrides.contact || 
        this.contactFactory.buildForMine(mineGroup, mineName),
      line_items: overrides.line_items !== undefined ? 
        overrides.line_items : 
        this.lineItemFactory.buildMany(Math.floor(Math.random() * 3) + 1),
      comment: overrides.comment !== undefined ? 
        overrides.comment : 
        this.randomFromArray(RequestFactory.COMMENTS),
      ...overrides
    };
  }
  
  buildMinimal(): TRequestUpsert {
    return this.build({
      line_items: [],
      contact: undefined,
      comment: undefined
    });
  }
  
  buildWithoutContact(): TRequestUpsert {
    return this.build({ contact: undefined });
  }
  
  buildWithoutLineItems(): TRequestUpsert {
    return this.build({ line_items: [] });
  }
  
  buildReadyToSubmit(): TRequestUpsert {
    return this.build({
      contact: this.contactFactory.build(),
      line_items: this.lineItemFactory.buildMany(2)
    });
  }
}

Create `/tests/_factories/db-request-factory.ts`:

import { BaseFactory } from './base-factory';
import { RequestFactory } from './request-factory';

export interface TestRequestDB {
  id: string;
  request_id: string;
  status: 'draft' | 'submitted' | 'in_progress' | 'won' | 'lost';
  salesperson_first_name?: string;
  mine_group?: string;
  mine_name?: string;
  contact?: any;
  line_items: any[];
  comment?: string;
  pipedrive_deal_id?: number;
  created_at: string;
  updated_at: string;
}

export class DBRequestFactory extends BaseFactory<TestRequestDB> {
  private requestFactory = new RequestFactory();

  build(overrides: Partial<TestRequestDB> = {}): TestRequestDB {
    const baseRequest = this.requestFactory.build();
    const now = new Date().toISOString();
    
    return {
      id: overrides.id || `00000000-0000-0000-0000-${this.nextId().toString().padStart(12, '0')}`,
      request_id: overrides.request_id || this.nextString('QR'),
      status: overrides.status || 'draft',
      salesperson_first_name: overrides.salesperson_first_name || baseRequest.salespersonFirstName,
      mine_group: overrides.mine_group || baseRequest.mineGroup,
      mine_name: overrides.mine_name || baseRequest.mineName,
      contact: overrides.contact !== undefined ? overrides.contact : baseRequest.contact,
      line_items: overrides.line_items !== undefined ? overrides.line_items : baseRequest.line_items,
      comment: overrides.comment !== undefined ? overrides.comment : baseRequest.comment,
      pipedrive_deal_id: overrides.pipedrive_deal_id || null,
      created_at: overrides.created_at || now,
      updated_at: overrides.updated_at || now,
      ...overrides
    };
  }
  
  buildDraft(): TestRequestDB {
    return this.build({ status: 'draft' });
  }
  
  buildSubmitted(): TestRequestDB {
    return this.build({ 
      status: 'submitted',
      pipedrive_deal_id: this.nextId() + 100000
    });
  }
}

Create `/tests/_factories/index.ts`:

export { ContactFactory } from './contact-factory';
export { LineItemFactory } from './line-item-factory';
export { RequestFactory } from './request-factory';
export { DBRequestFactory } from './db-request-factory';
export type { TestRequestDB } from './db-request-factory';

// Convenience instances
export const contactFactory = new ContactFactory();
export const lineItemFactory = new LineItemFactory();
export const requestFactory = new RequestFactory();
export const dbRequestFactory = new DBRequestFactory();
```

---

### 4. Test Data Lifecycle Management

**Goal:** Proper setup, seeding, and cleanup with no data leakage

**Cursor Prompt:**
```
Create comprehensive test data lifecycle management with proper cleanup.

Create `/tests/_utils/test-lifecycle.ts`:

import { getDb, getTableName } from '../../lib/db';
import { getRedisConfig } from '../../lib/config/test-env';
import { dbRequestFactory, type TestRequestDB } from '../_factories';

export class TestDataManager {
  private db = getDb();
  private redis;
  private trackedIds: string[] = [];
  private trackedKeys: string[] = [];

  constructor() {
    const config = getRedisConfig();
    this.redis = config.redis;
  }

  // Seed a request and track it for cleanup
  async seedRequest(overrides: Partial<TestRequestDB> = {}): Promise<TestRequestDB> {
    const testRequest = dbRequestFactory.build(overrides);
    
    const { data, error } = await this.db
      .from(getTableName('requests'))
      .insert(testRequest)
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to seed test request: ${error.message}`);
    }

    // Track for cleanup
    this.trackedIds.push(data.id);
    
    return data;
  }

  // Seed multiple requests
  async seedRequests(count: number, overrides: Partial<TestRequestDB> = {}): Promise<TestRequestDB[]> {
    const requests = await Promise.all(
      Array.from({ length: count }, () => this.seedRequest(overrides))
    );
    
    return requests;
  }

  // Seed cache data and track it
  async seedCache(key: string, data: any, ttl: number = 3600): Promise<void> {
    const config = getRedisConfig();
    const namespacedKey = config.getKey(key);
    
    await this.redis.setex(namespacedKey, ttl, JSON.stringify({
      data,
      timestamp: Date.now(),
      ttl: ttl * 1000
    }));
    
    // Track for cleanup
    this.trackedKeys.push(namespacedKey);
  }

  // Clean up all tracked data
  async cleanup(): Promise<void> {
    try {
      // Clean up database records
      if (this.trackedIds.length > 0) {
        await this.db
          .from(getTableName('requests'))
          .delete()
          .in('id', this.trackedIds);
        
        await this.db
          .from(getTableName('mockSubmissions'))
          .delete()
          .in('request_id', this.trackedIds);
      }

      // Clean up Redis keys
      if (this.trackedKeys.length > 0) {
        await this.redis.del(...this.trackedKeys);
      }

      // Reset tracking
      this.trackedIds = [];
      this.trackedKeys = [];
      
    } catch (error) {
      console.warn('Cleanup warning:', error);
      // Don't throw - cleanup should be best effort
    }
  }

  // Nuclear cleanup - removes ALL test data (use carefully)
  async nuclearCleanup(): Promise<void> {
    try {
      // Clean all test tables
      await this.db.from(getTableName('requests')).delete().neq('id', '');
      await this.db.from(getTableName('kvCache')).delete().neq('key', '');
      await this.db.from(getTableName('mockSubmissions')).delete().neq('id', '');

      // Clean all test Redis keys
      const config = getRedisConfig();
      const pattern = config.getKey('*');
      const keys = await this.redis.keys(pattern);
      
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
      
    } catch (error) {
      console.warn('Nuclear cleanup warning:', error);
    }
  }
}

Create `/tests/_utils/test-helpers.ts`:

import { expect } from 'vitest';
import { TestDataManager } from './test-lifecycle';
import { TContactJSON, TLineItem } from '../../lib/schema';

export const testDataManager = new TestDataManager();

// Custom assertions that prevent null-checking defensive code
export const assertValidContact = (contact: any): asserts contact is TContactJSON => {
  expect(contact).toBeDefined();
  expect(contact).not.toBeNull();
  expect(contact.personId).toBeTypeOf('number');
  expect(contact.personId).toBeGreaterThan(0);
  expect(contact.name).toBeTypeOf('string');
  expect(contact.name.length).toBeGreaterThan(0);
  expect(contact.email).toBeTypeOf('string');
  expect(contact.email).toMatch(/^[^\s@]+@[^\s@]+\.[^\s@]+$/);
  expect(contact.phone).toBeTypeOf('string');
  expect(contact.phone.length).toBeGreaterThan(0);
  expect(contact.orgId).toBeTypeOf('number');
  expect(contact.orgId).toBeGreaterThan(0);
  expect(contact.orgName).toBeTypeOf('string');
  expect(contact.orgName.length).toBeGreaterThan(0);
  expect(contact.mineGroup).toBeTypeOf('string');
  expect(contact.mineGroup.length).toBeGreaterThan(0);
  expect(contact.mineName).toBeTypeOf('string');
  expect(contact.mineName.length).toBeGreaterThan(0);
};

export const assertValidLineItem = (lineItem: any): asserts lineItem is TLineItem => {
  expect(lineItem).toBeDefined();
  expect(lineItem).not.toBeNull();
  expect(lineItem.pipedriveProductId).toBeTypeOf('number');
  expect(lineItem.pipedriveProductId).toBeGreaterThan(0);
  expect(lineItem.name).toBeTypeOf('string');
  expect(lineItem.name.length).toBeGreaterThan(0);
  expect(lineItem.code).toBeTypeOf('string');
  expect(lineItem.code.length).toBeGreaterThan(0);
  expect(lineItem.category).toBeTypeOf('string');
  expect(lineItem.category.length).toBeGreaterThan(0);
  expect(lineItem.price).toBeTypeOf('number');
  expect(lineItem.price).toBeGreaterThanOrEqual(0);
  expect(lineItem.quantity).toBeTypeOf('number');
  expect(lineItem.quantity).toBeGreaterThan(0);
  expect(lineItem.shortDescription).toBeTypeOf('string');
};

export const assertValidLineItems = (lineItems: any[]): void => {
  expect(lineItems).toBeInstanceOf(Array);
  expect(lineItems.length).toBeGreaterThan(0);
  lineItems.forEach(assertValidLineItem);
};

// Helper to assert request can be submitted (has both contact and line items)
export const assertSubmittable = (request: any): void => {
  assertValidContact(request.contact);
  assertValidLineItems(request.line_items);
};

// Mock data providers with guaranteed valid data
export const getMockContactsResponse = () => ({
  ok: true,
  data: {
    'Anglo American': {